{"1":{"filename":"lib/sekret/octree.txt","code":"--[[\nSpace Combat Octree Builder - Created by Lt.Brandon, based on work by Steeveeo\n\nIf you're not from the diaspora development team and you're viewing this file then please go commit seppuku in the corner :)\n]]--\n\n--Global Tables\nSC.Octree = {}\nSC.Octree.Builder = {}\nSC.Octree.Octant = {}\n\n--Octant Functions\nfunction SC.Octree.Octant:New(Origin, Size, IsRoot, Parent)\n    if not Origin or not Size or ((not IsRoot) and (not Parent)) then\n        print(\"[Space Combat 2 - Octree Builder] Unable to create octant, invalid parameters\\n\")\n        return false\n    end\n\n    local obj = {}\n\tsetmetatable(obj,self)\n    obj.Parent = Parent\n    obj.Size = Size\n    obj.Position = Origin\n    obj.Children = {}\n    obj.IsRoot = IsRoot\n    obj.IsBlocked = false\n\n    if IsRoot then\n        obj.Root = obj\n        obj.OctantCount = 1\n    else\n        obj.Root = Parent.Root\n        obj.Root.OctantCount = obj.Root.OctantCount + 1\n    end\n\n    return obj\nend\n\nfunction SC.Octree.Octant:IsLeaf()\n    return #self.Children == 0\nend\n\nfunction SC.Octree.Octant:IsPointInOctant(Point)\n    local Center = self.Position\n    local Size = self.Size\n    local Min = Center - Vector(Size * 0.5, Size * 0.5, Size * 0.5)\n    local Max = Center + Vector(Size * 0.5, Size * 0.5, Size * 0.5)\n    \n    return Point:WithinAABox(Min, Max)\nend\n\nfunction SC.Octree.Octant:GetPointOctant(Point)\n    if self:IsLeaf() and self:IsPointInOctant(Point) then\n        return self\n    elseif self.Children then\n        local Octants = self.Children\n        for I = 1, 8 do\n            local SubOctant = Octants[I]\n            if SubOctant:IsPointInOctant(Point) then\n                return SubOctant:GetPointOctant(Point)\n            end\n        end\n    else\n        print(\"[Space Combat 2 - Octree Builder] - Unable to find the octant which held the point!\\n\")\n        return false\n    end\nend\n\nfunction SC.Octree.Octant:Check(CheckEntities)\n    local Size = self.Size\n    local Trace = util.TraceHull({\n\t    start = self.Position, \n\t    endpos = self.Position, \n\t    filter = player.GetAll(),\n\t    mins = Vector(self.Size * -0.5, self.Size * -0.5, self.Size * -0.5), \n\t    maxs = Vector(self.Size * 0.5, self.Size * 0.5, self.Size * 0.5),\n        mask = CheckEntities and nil or MASK_NPCWORLDSTATIC\n    })\n\n    if Trace.Hit then\n        return true\n    end\n\n    return false\nend\n\nfunction SC.Octree.Octant:Subdivide()\n    local Origin = self.Position\n    local NewScanVolume = self.Size * 0.5\n    local Dist = NewScanVolume * 0.5\n    \n    local Children = {}\n    Children[1] = SC.Octree.Octant:New(Origin + Vector(Dist, Dist, Dist), NewScanVolume, false, self)\n    Children[2] = SC.Octree.Octant:New(Origin + Vector(Dist, -Dist, Dist), NewScanVolume, false, self)\n    Children[3] = SC.Octree.Octant:New(Origin + Vector(-Dist, Dist, Dist), NewScanVolume, false, self)\n    Children[4] = SC.Octree.Octant:New(Origin + Vector(-Dist, -Dist, Dist), NewScanVolume, false, self)\n    Children[5] = SC.Octree.Octant:New(Origin + Vector(Dist, Dist, -Dist), NewScanVolume, false, self)\n    Children[6] = SC.Octree.Octant:New(Origin + Vector(Dist, -Dist, -Dist), NewScanVolume, false, self)\n    Children[7] = SC.Octree.Octant:New(Origin + Vector(-Dist, Dist, -Dist), NewScanVolume, false, self)\n    Children[8] = SC.Octree.Octant:New(Origin + Vector(-Dist, -Dist, -Dist), NewScanVolume, false, self)\n\n    self.Children = Children\nend\nSC.Octree.Octant.__index = SC.Octree.Octant\n\n--Builder Functions\nfunction SC.Octree.Builder:New(Position, Size, MaxDepth, CheckEntities, MaxTime, FinishedCallback)\n    local obj = {}\n\tsetmetatable(obj,self)\n    obj.Position = Position\n    obj.Size = Size\n    obj.MaxDepth = MaxDepth\n    obj.CheckEntities = CheckEntities\n    obj.MaxTime = MaxTime\n    obj.RootOctant = SC.Octree.Octant:New(Position, Size, true)\n    obj.RootOctant:Subdivide()\n    obj.Finished = false\n    obj.CurDepth = 1\n    obj.CurParent = obj.RootOctant\n    obj.CurOctant = obj.RootOctant.Children[1]\n    obj.OctantIndex = {}\n    obj.OctantIndex[1] = 1\n    obj.FinishedCallback = FinishedCallback\n    obj.StartTime = -1\n    obj.StopTime = -1\n\n    return obj\nend\n\nfunction SC.Octree.Builder:Rebuild(running)\n    if not running then self.StartTime = SysTime() end\n    local Finished = self.Finished\n    local finishtime = SysTime() + self.MaxTime\n    local time = SysTime()\n    \n    while time < finishtime and not Finished do\n        time = SysTime()\n\n        --Check if this octant should be a leaf\n        if not self.CurOctant:Check(self.CheckEntities) then\n            --Iterate back up the Octree\n            while self.OctantIndex[self.CurDepth] >= 8 do\n            \n                self.CurDepth = self.CurDepth - 1\n\n                --Top of tree, break\n                if self.CurDepth < 1 then\n                    Finished = true\n                    break\n                else\n                    self.CurOctant = self.CurParent\n                    self.CurParent = self.CurOctant.Parent\n                end\n            end\n        --We found something, so subdivide\n        else\n            --We are at max depth, pop back up a level\n            if self.CurDepth >= self.MaxDepth then\n                --Mark Invalid\n                self.CurOctant.IsBlocked = true\n                \n                while self.OctantIndex[self.CurDepth] >= 8 do\n                    self.CurDepth = self.CurDepth - 1\n\n                    --Top of tree, break\n                    if self.CurDepth < 1 then\n                        Finished = true\n                        break\n                    else\n                        self.CurOctant = self.CurParent\n                        self.CurParent = self.CurOctant.Parent\n                    end\n                end\n            --Else subdivide and iterate downwards\n            else\n                self.CurOctant:Subdivide()\n                self.CurDepth = self.CurDepth + 1\n                \n                self.OctantIndex[self.CurDepth] = 0\n                self.CurParent = self.CurOctant\n            end\n        end\n                \n        --Next Octant\n        if not Finished then\n            self.OctantIndex[self.CurDepth] = self.OctantIndex[self.CurDepth] + 1\n            self.CurOctant = self.CurParent.Children[self.OctantIndex[self.CurDepth]]\n        end\n    end\n    \n    if not Finished then\n        print(\"[Space Combat 2 - Octree Builder] - Built \"..self.RootOctant.OctantCount..\" Octants\\n\")\n        timer.Simple(0.1, function()\n            if self then\n                self:Rebuild(true)\n            end\n        end)\n    else\n        self.StopTime = SysTime()\n        print(\"[Space Combat 2 - Octree Builder] - Finished Building.\\n\")\n        self.Finished = true\n\n        if self.FinishedCallback then\n            self:FinishedCallback()\n        end\n    end\nend\nSC.Octree.Builder.__index = SC.Octree.Builder"},"2":{"filename":"octreeeeeeeeeeeeeeeeeeeeees.txt","code":"--@name octreeeeeeeeeeeeeeeeeeeeees\n--@author Hab\n--@include lib/sekret/octree.txt\nif SERVER then \n    require(\"lib/sekret/octree.txt\")\n    \n    --override this so we can hit what we want. \n    function SC.Octree.Octant:Check(CheckEntities)\n        local Size = self.Size\n        local Trace = trace.TraceHull(\n            self.Position, \n    \t    self.Position, \n    \t    Vector(self.Size * -0.5, self.Size * -0.5, self.Size * -0.5), \n    \t    Vector(self.Size * 0.5, self.Size * 0.5, self.Size * 0.5),\n    \t    {},\n            CheckEntities and nil or MASK_NPCWORLDSTATIC\n        )\n        if Trace.Hit then return true else return false end\n    end\n\n    hoboctant = SC.Octree.Builder:New(entities.self():GetPos(), 512, 4, true, 0.01, function() loop(hoboctant.RootOctant) end)\n    hoboctant:Rebuild()\n    local octols = {}\n    function loop(octo)\n        \n        for I = 1 , #octo.Children do\n            local V = octo.Children[I]\n            if #V.Children > 0 then \n                loop(V)\n            end\n            table.insert(octols,V)\n        end\n    end\n    \n    function depthMeter(octo)\n        local Depth = 1\n        local O = octo\n        for I = 1 , hoboctant.MaxDepth do\n            if O.Parent == hoboctant.RootOctant then \n                return Depth\n            else\n                Depth = Depth + 1 \n                O = O.Parent\n            end\n        end\n    end\n    local I = 0\n    hook.Add(\"Think\",\"Think\",function()\n        if I<#octols and holograms.canSpawn() then\n            I=I+1\n            if depthMeter(octols[I])>3 then\n                local E = holograms.create(octols[I].Position,Angle(0,0,0),\"models/sprops/cuboids/height06/size_1/cube_6x6x6.mdl\",Vector(0.16,0.16,0.16)*octols[I].Size)\n                print(octols[I].Position)\n                E:SetColor(Color(0,255,0))\n                if octols[I].IsBlocked then \n                    E:SetColor(Color(255,0,0))\n                end\n            end\n        end\n    end)\n\nend"},"selectedTab":2}