{"1":{"filename":"HobScreen.txt","code":"--@name HobScreen\n--@author \n--@shared\n\nme = FindPlayerByName(\"H08\")\n\nif SERVER then\n    \n    active = {}\n    \n    hook.Add(\"PlayerSay\",\"HideUtilHud\",function(ply,text)\n        local t = string.lower(text)\n        if t == \"!cam\" then\n            net.Start(\"HideUtilHud\")\n                net.WriteBool(false)\n            net.Send(me)\n            return \"\"\n        elseif t == \"!camoff\" then\n            net.Start(\"HideUtilHud\")\n                net.WriteBool(true)\n            net.Send(me)\n            return \"\"\n        end\n    end)\n    \n    function RemoveTarget(core)\n        if core and core:IsValid() then\n            active[core] = nil\n            net.Start(\"RemoveCoreTarget\")\n                net.WriteUInt(core:EntIndex(),13)\n            net.Send(me)\n        end\n    end\n\n    function UpdateTargets()\n        local keys = table.GetKeys(active)\n        for i=#keys,1,-1 do\n            if not keys[i]:IsValid() then table.remove(active,keys[i]) end\n        end\n        for core,_ in pairs(active) do\n            net.Start(\"UpdateCoreTarget\")\n                net.WriteUInt(core:EntIndex(), 13)\n                net.WriteUInt(core:GetShieldAmount(), 32)\n                net.WriteUInt(core:GetShieldMax(), 32)\n                net.WriteUInt(core:GetArmorAmount(), 32)\n                net.WriteUInt(core:GetArmorMax(), 32)\n                net.WriteUInt(core:GetHullAmount(), 32)\n                net.WriteUInt(core:GetHullMax(), 32)\n            net.Send(me)\n        end\n    end\n    \n    function CheckAim() \n        local aiment = me:GetEyeTrace().Entity\n        if aiment and aiment:IsValid() then\n            local core = aiment:GetCoreEntity()\n            if core and core:IsValid() then\n                if not active[core] then\n                    active[core] = core\n                    net.Start(\"NewCoreTarget\")\n                        net.WriteUInt(core:EntIndex(), 13)\n                        net.WriteString(core:GetShipClass())\n                        net.WriteString(core:GetShipName())\n                        net.WriteUInt(core:GetShieldAmount(), 32)\n                        net.WriteUInt(core:GetShieldMax(), 32)\n                        net.WriteUInt(core:GetArmorAmount(), 32)\n                        net.WriteUInt(core:GetArmorMax(), 32)\n                        net.WriteUInt(core:GetHullAmount(), 32)\n                        net.WriteUInt(core:GetHullMax(), 32)\n                    net.Send(me)\n                end\n                timer.Create(\"remove\"..core:EntIndex(),3,1,function() RemoveTarget(core) end)\n            end\n        end\n    end\n    \n    timer.Create(\"scan\",0.3,0,CheckAim)\n    timer.Create(\"update\",1,0,UpdateTargets)\n    \nelse\n    if entities.player() == me then\n        Players = find.AllPlayers()\n        LPly = entities.player()\n        active = true\n        cores = {}\n        \n        TeamColours ={\n            Color(100,255,255), -- 1 ?\n            Color(255,100,255), -- 2 ? \n            Color(255,255,100), -- 3 ?\n            Color(100,255,100), -- 4 Player\n            Color(255,0,0),     -- 5 Administrator\n            Color(255,255,0),   -- 6 Respected Player\n            Color(255,255,255)} -- clamp\n        \n        \n        function DrawWedge(px,py,w,h,angle,size,col)\n        \tlocal vertices = {}\n        \tlocal fidelity = 180\n        \n        \tvertices[1] = { x = px, y = py, u = px, v = py }\n        \tlocal ang = -math.rad(angle)\n        \tlocal c = math.cos(ang)\n        \tlocal s = math.sin(ang)\n        \tfor ii=0,fidelity do\n        \t\tlocal i = ii*(size)/fidelity\n        \t\tlocal radd = math.rad(i)\n        \t\tlocal x = math.cos(radd)\n        \t\tlocal u = (x+1)/2\n        \t\tlocal y = math.sin(radd)\n        \t\tlocal v = (y+1)/2\n        \n        \t\t--radd = -rad(angle)\n        \t\tlocal tempx = x * w * c - y * h * s + x\n        \t\ty = x * w * s + y * h * c + y\n        \t\tx = tempx\n        \n        \t\tvertices[ii+2] = { x = x+px, y = y+py, u = u + px, v = v + py }\n        \tend\n        \n        \tsurface.SetDrawColor( col )\n        \tif (vertices and #vertices>0) then\n        \t\tsurface.DrawPoly( vertices )\n        \tend\n        end\n        hook.Add(\"HUDPaint\",\"UtilHud\",function()\n            --players\n            if LPly:IsValid() and LPly:Alive() and LPly:GetActiveWeapon()~=\"weapon_stunstick\" and active then\n                if #Players > 0 then\n                    for _,P in pairs(Players) do\n                        if P ~= nil and P:IsValid() then\n                            if P~=LPly then\n                                local vec = (P:OBBCenterW()+Vector(0,0,P:OBBSize().z/2 + 10))\n                                local dist = vec:Distance(LPly:EyePos())\n                                local toScrn = (vec + Vector(0,0,dist*0.02)):ToScreen()\n                                local pos = {x=math.Clamp(toScrn.x,100,surface.ScreenW()-100),y=math.Clamp(toScrn.y,100,surface.ScreenH()-100)}\n                                if(P:Team()) then\n                                    surface.SetTextColor(TeamColours[math.Clamp(P:Team(),1,7)])\n                                end\n                                surface.SetFont(\"Default\")\n                                local w,h =surface.GetTextSize(P:GetName())\n                                surface.SetTextPos(pos.x -w/2,pos.y+10)\n                                surface.DrawText(P:GetName())\n                            end\n                        end\n                    end\n                end\n                if #cores then\n                    local keys = table.GetKeys(cores)\n                    for i=#keys,1,-1 do\n                        if not keys[i]:IsValid() then table.remove(cores,keys[i]) end\n                    end\n                    for c,t in pairs(cores) do\n                        local vec = c:LocalToWorld(c:OBBCenter())\n                        local toScrn = vec:ToScreen()\n                        local pos = {x=math.Clamp(toScrn.x,100,surface.ScreenW()-100),y=math.Clamp(toScrn.y,100,surface.ScreenH()-100)}\n\n                        local HPMax = t.shieldmax + t.armormax + t.hullmax\n                        local HuAng = (t.hull / HPMax)*360\n                        local ArAng = (t.armor / HPMax)*360\n                        local ShAng = (t.shield / HPMax)*360\n                        DrawWedge(pos.x,pos.y,40,40,90,-HuAng,Color(255,0,0,255))\n                        DrawWedge(pos.x,pos.y,40,40,90+HuAng,-ArAng,Color(155,155,155,255))\n                        DrawWedge(pos.x,pos.y,40,40,90+HuAng+ArAng,-ShAng,Color(0,0,255,255))\n                        surface.DrawCircle(pos.x,pos.y,40,Color(55,55,55,255))\n                        surface.SetDrawColor(Color(55,55,55,255))\n                        surface.SetTextColor(Color(255,255,255,255))\n                        surface.SetTextPos(pos.x+34,pos.y-40)\n                        surface.DrawText(t.class)\n                        surface.SetTextPos(pos.x+42,pos.y-25)\n                        surface.DrawText(t.name)\n                    end\n                end\n            end\n            -- hook.Remove(\"HUDPaint\",\"UtilHud\")\n        end)\n        \n        timer.Create(\"refresh\",15,0,function() \n            Players = find.AllPlayers()\n        end)\n        \n        hook.Add(\"net\", \"HideUtilHud\", function(name, len, ply)\n            if name == \"HideUtilHud\" then\n                active = net.ReadBool()\n            elseif name == \"NewCoreTarget\" then\n                local core = Entity(net.ReadUInt(13))\n                cores[core] = {\n                        class=net.ReadString(),\n                        name=net.ReadString(),\n                        shield=net.ReadInt(32),\n                        shieldmax=net.ReadInt(32),\n                        armor=net.ReadInt(32),\n                        armormax=net.ReadInt(32),\n                        hull=net.ReadInt(32),\n                        hullmax=net.ReadInt(32)\n                    }\n            elseif name == \"UpdateCoreTarget\" then\n                local core = Entity(net.ReadUInt(13))\n                cores[core].shield=net.ReadInt(32)\n                cores[core].shieldmax=net.ReadInt(32)\n                cores[core].armor=net.ReadInt(32)\n                cores[core].armormax=net.ReadInt(32)\n                cores[core].hull=net.ReadInt(32)\n                cores[core].hullmax=net.ReadInt(32)\n            elseif name == \"RemoveCoreTarget\" then\n                local core = Entity(net.ReadUInt(13))\n                cores[core] = nil\n            end\n        end)\n    end\nend"},"2":{"filename":"Hob Screen 3.txt","code":"--@name Hob Screen 3\n--@author \n--@shared\n\nif SERVER then\n    hook.Add(\"Think\",\"Think\",function()\n        if not net.CanSend() then return end\n        \n        local Tbl = {}\n        for k,v in pairs(find.ByClass(\"ship_core\")) do\n            Tbl[v] = {\n                shield = v:GetShieldAmount(),\n                shieldmax = v:GetShieldMax(),\n                armour = v:GetArmorAmount(),\n                armourmax = v:GetArmorMax(),\n                hull = v:GetHullAmount(),\n                hullmax = v:GetHullMax(),\n                name = v:GetShipName(),\n                class = v:GetShipClass()\n            }\n        end\n        net.Start(\"Update Core Table\")\n        net.WriteTable(Tbl)\n        net.Send()\n    end)\nelse\n    if entities.player() == entities.owner() then\n        ShipCores = {}\n        hook.Add(\"net\",\"HobNetMessage\",function(name,len)\n            if not name == \"Update Core Table\" then return end\n            ShipCores = {}\n            ShipCores = net.ReadTable()\n        end)\n        \n        function DrawWedge(px,py,w,h,angle,size,col,uvenum) --1= right to left, 2 = from center outwards\n        \tlocal vertices = {}\n        \tlocal fidelity = 180\n        \n        \tvertices[1] = { x = px, y = py, u = px, v = py }\n        \tlocal ang = -math.rad(angle)\n        \tlocal c = math.cos(ang)\n        \tlocal s = math.sin(ang)\n        \tfor ii=0,fidelity do\n        \t\tlocal i = ii*(size)/fidelity\n        \t\tlocal radd = math.rad(i)\n        \t\tlocal x = math.cos(radd)\n        \t\tlocal y = math.sin(radd)\n            \tlocal u = 0\n            \tlocal v = 0\n        \t\tif not uvenum or uvenum == 1 then \n            \t\tu = (x+1)/2\n            \t\tv = (y+1)/2\n            \telseif uvenum == 2 then\n            \t    u = 0\n            \t    v = 1\n            \tend\n        \n        \t\t--radd = -rad(angle)\n        \t\tlocal tempx = x * w * c - y * h * s + x\n        \t\ty = x * w * s + y * h * c + y\n        \t\tx = tempx\n        \n        \t\tvertices[ii+2] = { x = x+px, y = y+py, u = u + px, v = v + py }\n        \tend\n            surface.SetDrawColor( col )\n    \t    if (vertices and #vertices>0) then\n    \t\t    surface.DrawPoly( vertices )\n    \t    end\n        end\n        function DrawArc( px, py, r, r2, size, angle, col, calcuvf)\n            local fidelity = 10\n            size = math.abs(size)\n            surface.SetDrawColor( col )\n            \n            local MaxX = 0\n            local MaxY = 0\n            if size >= 180 then \n                MaxX = r*2\n            else \n                MaxX = math.cos(math.rad(size))*r + r\n            end\n            if size < 90 then \n                MaxY = math.sin(math.rad(size))*r\n            elseif size <= 180 then\n                MaxY = r\n            elseif size < 270 then \n                MaxY = r + math.abs(math.sin(math.rad(size)))*r\n            else \n                MaxY = r*2\n            end\n            local function defaultcalcuv(x,y,MaxX,MaxY)\n                print(MaxX/2 - x)\n                return math.Clamp(x / MaxX,0,1) , math.Clamp(y / MaxY,0,1)\n            end\n        \n            local calcuv = calcuvf or defaultcalcuv\n            \n            for i = 1, fidelity do\n                local a1 = math.rad(i*(size/fidelity))\n                local v1 = {}\n                v1.x = math.cos(a1) * r -- point c\n                v1.y = math.sin(a1) * r\n                v1.u, v1.v = calcuv(v1.x,v1.y,MaxX,MaxY)\n                v1.x = v1.x + px\n                v1.y = v1.y + py\n                \n                local a2 = math.rad((i-1)*(size/fidelity))\n                local v2 = {}\n                v2.x = math.cos(a2) * r -- point a\n                v2.y = math.sin(a2) * r\n                v2.u, v2.v = calcuv(v2.x,v2.y,MaxX,MaxY)\n                v2.x = v2.x + px\n                v2.y = v2.y + py\n                \n                local a3 = math.rad((i-1)*(size/fidelity))\n                local v3 = {}\n                v3.x = math.cos(a3) * r2 -- point b\n                v3.y = math.sin(a3) * r2\n                v3.u, v3.v = calcuv(v3.x,v3.y,MaxX,MaxY)\n                v3.x = v3.x + px\n                v3.y = v3.y + py\n\n                surface.DrawPoly( {v3,v2,v1} )\n            end\n            for i = 1, fidelity do\n                local a1 = math.rad(i*(size/fidelity))\n                local v1 = {}\n                v1.x = math.cos(a1) * r2 -- point d\n                v1.y = math.sin(a1) * r2\n                v1.u, v1.v = calcuv(v1.x,v1.y,MaxX,MaxY)\n                v1.x = v1.x + px\n                v1.y = v1.y + py\n                \n                local a2 = math.rad((i-1)*(size/fidelity)) -- point b\n                local v2 = {}\n                v2.x = math.cos(a2) * r2\n                v2.y = math.sin(a2) * r2\n                v2.u, v2.v = calcuv(v2.x,v2.y,MaxX,MaxY)\n                v2.x = v2.x + px\n                v2.y = v2.y + py\n                \n                local a3 = math.rad((i)*(size/fidelity)) -- point c\n                local v3 = {}\n                v3.x = math.cos(a3) * r\n                v3.y = math.sin(a3) * r\n                v3.u, v3.v = calcuv(v3.x,v3.y,MaxX,MaxY)\n                v3.x = v3.x + px\n                v3.y = v3.y + py\n                \n                surface.DrawPoly( {v1,v2,v3} )\n            end\n        end\n        \n        function halfuv(x,y,MaxX,MaxY)\n            print(MaxX,MaxY)\n            return -math.Clamp(((MaxX/2-x) / MaxX) ,0,1) , -math.Clamp((MaxY/2-y) / MaxY,0,1)\n        end\n        mat = Material(\"gui/gradient\")\n    \n        hook.Add(\"HUDPaint\",\"HobHud\",function()\n            local Pos = {x=surface.ScreenW()/2, y=surface.ScreenH()-250}\n\n            surface.SetMaterial(mat)\n            DrawArc( Pos.x,Pos.y,130,80,90,0,Color(255,255,255))\n            surface.SetTexture(-1)\n            --DrawArc( Pos.x,Pos.y,129,80,180,0,Color(0,0,0))\n        end)\n    end\nend"},"3":{"filename":"Hob Screen 2.txt","code":"--@name Hob Screen 2\n--@author \n--@shared\n\nif SERVER then\n    hook.Add(\"Think\",\"Think\",function()\n        if not net.CanSend() then return end\n        \n        local Tbl = {}\n        for k,v in pairs(find.ByClass(\"ship_core\")) do\n            Tbl[v] = {\n                shield = v:GetShieldAmount(),\n                shieldmax = v:GetShieldMax(),\n                armour = v:GetArmorAmount(),\n                armourmax = v:GetArmorMax(),\n                hull = v:GetHullAmount(),\n                hullmax = v:GetHullMax(),\n                name = v:GetShipName(),\n                class = v:GetShipClass()\n            }\n        end\n        net.Start(\"Update Core Table\")\n        net.WriteTable(Tbl)\n        net.Send()\n    end)\nelse\n    if entities.player() == entities.owner() or true then\n        ShipCores = {}\n        hook.Add(\"net\",\"HobNetMessage\",function(name,len)\n            if not name == \"Update Core Table\" then return end\n            ShipCores = {}\n            ShipCores = net.ReadTable()\n        end)\n        \n        function DrawWedge(px,py,w,h,angle,size,col)\n        \tlocal vertices = {}\n        \tlocal fidelity = 180\n        \n        \tvertices[1] = { x = px, y = py, u = px, v = py }\n        \tlocal ang = -math.rad(angle)\n        \tlocal c = math.cos(ang)\n        \tlocal s = math.sin(ang)\n        \tfor ii=0,fidelity do\n        \t\tlocal i = ii*(size)/fidelity\n        \t\tlocal radd = math.rad(i)\n        \t\tlocal x = math.cos(radd)\n        \t\tlocal u = (x+1)/2\n        \t\tlocal y = math.sin(radd)\n        \t\tlocal v = (y+1)/2\n        \n        \t\t--radd = -rad(angle)\n        \t\tlocal tempx = x * w * c - y * h * s + x\n        \t\ty = x * w * s + y * h * c + y\n        \t\tx = tempx\n        \n        \t\tvertices[ii+2] = { x = x+px, y = y+py, u = u + px, v = v + py }\n        \tend\n            surface.SetDrawColor( col )\n    \t    if (vertices and #vertices>0) then\n    \t\t    surface.DrawPoly( vertices )\n    \t    end\n        end\n        \n        \n        hook.Add(\"HUDPaint\",\"HobHud\",function()\n            for c,t in pairs( ShipCores ) do\n                if not c:IsValid() then continue end\n                local vec = c:LocalToWorld(c:OBBCenter())\n                local toScrn = vec:ToScreen()\n                local pos = {x=math.Clamp(toScrn.x,100,surface.ScreenW()-100),y=math.Clamp(toScrn.y,100,surface.ScreenH()-100)}\n                local HPMax = t.shieldmax + t.armourmax + t.hullmax\n                local HuAng = (t.hull / HPMax)*360\n                local ArAng = (t.armour / HPMax)*360\n                local ShAng = (t.shield / HPMax)*360\n                \n                DrawWedge(pos.x,pos.y,40,40,90,-HuAng,Color(255,0,0,255))\n                DrawWedge(pos.x,pos.y,40,40,90+HuAng,-ArAng,Color(155,155,155,255))\n                DrawWedge(pos.x,pos.y,40,40,90+HuAng+ArAng,-ShAng,Color(0,0,255,255))\n                surface.DrawCircle(pos.x,pos.y,40,Color(55,55,55,255))\n                surface.SetDrawColor(Color(55,55,55,255))\n                surface.SetTextColor(Color(255,255,255,255))\n                surface.SetTextPos(pos.x, pos.y + 60 )\n                surface.DrawText(t.name)\n                surface.SetTextPos(pos.x, pos.y + 80 )\n                surface.DrawText(t.class)\n            end\n        end)\n    end\nend"},"4":{"filename":"projects/plane/plane.txt","code":"--@name Plane\n--@author \n--@shared\n\nif SERVER then\n    \n    Throttle = 0\n    W = 0\n    A = 0\n    S = 0\n    D = 0\n    Shift = 0\n    Space = 0\n    Seat = 0\n    Mass = 0\n    for K,V in pairs(entities.self():GetAllConstrainedEnts()) do\n        Mass = Mass + V:GetMass()\n        if(V:GetClass() == \"prop_vehicle_prisoner_pod\") then \n            Seat = V:EntIndex()\n        end\n    end\n    Driver = entities.entity(Seat):GetDriver() \n    Text = \"\"\n    Offset = Vector(0,0,0)\n    function NetworkVars()\n        if net.CanSend() then\n            net.Start(\"Throttle\")\n            net.WriteDouble(Throttle)\n            if Driver:IsValid() then\n                net.WriteInt(Driver:EntIndex(),8)\n            else\n                net.WriteInt(-1,8)\n            end\n            net.WriteString(Text)\n            net.Send()\n        end\n    end\n    \n    hook.Add(\"KeyPress\",\"HobPress\",function(ply,key)\n        if ply == Driver then\n            if key == 8 then\n                W = 1\n            elseif key == 512 then\n                A = 1\n            elseif key == 16 then\n                S = 1\n            elseif key == 1024 then\n                D = 1\n            elseif key == 131072 then\n                Shift = 1\n            elseif key == 2 then\n                Space = 1\n            end\n        end\n    end)\n    hook.Add(\"KeyRelease\",\"HobRelease\",function(ply,key)\n        if ply == Driver then\n            if key == 8 then\n                W = 0\n            elseif key == 512 then\n                A = 0\n            elseif key == 16 then\n                S = 0\n            elseif key == 1024 then\n                D = 0\n            elseif key == 131072 then\n                Shift = 0\n            elseif key == 2 then\n                Space = 0\n            end\n        end\n    end)\n    \n    Holo = holograms.create(entities.self():GetPos(),Angle(0,0,0),\"models/hunter/blocks/cube025x025x025.mdl\",Vector(1,1,1))\n    Holo:SetColor(Color(255,0,0))\n    hook.Add(\"Think\",\"HobThink\",function() \n        \n        local ThrstMul = 50 * Mass\n        local PitchMul = 5 * Mass\n        local YawMul = 5 * Mass\n        local RollMul = 500 * Mass\n        \n        --internal vars\n        local Ent = entities.self():IsWeldedTo()\n        Driver = entities.entity(Seat):GetDriver() \n        Throttle = math.Clamp(Throttle + W/100 - S/100, 0 , 1)\n        if Driver:IsValid() then \n            Holo:setPos(Driver:EyePos() + Driver:EyeAngles():Forward()*500 +Offset)\n            Ang = (Driver:EyePos() - Holo:GetPos()):Angle()\n            Ang[2] = Ang[2] - Ent:GetAngles()[2]\n            Ang[2] = Ang[2] + 90\n            Ang[1] = Ang[1] - Ent:GetAngles()[3]\n            Ang:Normalize()\n            Text = \"Pitch: \" .. math.Round(Ang[1]) .. \" Yaw: \" .. math.Round(Ang[2]) .. \" Roll: \" .. (D-A)\n            Ent:ApplyAngForce(Angle(RollMul*(D-A),YawMul*Ang[2],PitchMul*Ang[1]))\n            Ent:ApplyForceCenter(-Ent:GetRight()*ThrstMul*Throttle)\n        end\n        NetworkVars()\n    end)\n    \n\n\nelse\n    Driver = nil\n    Text = \"\"\n    hook.Add(\"net\",\"HobNet\",function(Name)\n        if Name == \"Throttle\" then\n            Throttle = net.ReadDouble()\n            Driver = entities.entity(net.ReadInt(8))\n            Text = net.ReadString()\n        end\n    end)\n    Throttle = 0.5\n    hook.Add(\"HUDPaint\",\"HobPaint\",function() \n        if entities.player() == Driver then\n            local w,h = surface.ScreenW(), surface.ScreenH()\n            surface.SetDrawColor(Color(200,200,200))\n            surface.DrawRect(21,h-160,290,30)\n            surface.SetDrawColor(Color(100,100,100))\n            surface.DrawRect(23,h-158,286*Throttle,26)\n            surface.SetTextColor(Color(255,255,255))\n            surface.SetTextPos(23,h-175)\n            surface.DrawText(Text)\n        end\n    end)\nend"},"5":{"filename":"examples/lib/class.txt","code":"--@name Class\r\n--@author Xandaros\r\n\r\n--Class library, most recent version can be found here: https://gist.github.com/Xandaros/ea8756e4c4ba00218855\r\n\r\nlocal function callConstructor(class, obj, ...)\r\n    local meta = getmetatable(class)\r\n    if meta.__super then\r\n        if class.superArgs then\r\n            callConstructor(meta.__super, obj, class.superArgs(...))\r\n        else\r\n            callConstructor(meta.__super, obj)\r\n        end\r\n    end\r\n    if class.constructor then\r\n        class.constructor(obj, ...)\r\n    end\r\nend\r\n\r\nlocal function instantiate(class, ...)\r\n    local ret = setmetatable({}, {\r\n        __index = class\r\n    })\r\n    callConstructor(class, ret, ...)\r\n    return ret\r\nend\r\n\r\nfunction Class(name, superclass)\r\n    local ret = {}\r\n    setmetatable(ret, {\r\n        __index = function(self, key)\r\n            if key ~= \"constructor\" and superclass then\r\n                return superclass[key]\r\n            end\r\n            return nil\r\n        end,\r\n        --__index = superclass,\r\n        __super = superclass,\r\n        __call = instantiate,\r\n        __tostring = function() return name or \"unknown\" end\r\n    })\r\n    return ret\r\nend\r\n\r\n-- vim: set filetype=lua :\r\n"},"6":{"filename":"lib/class.txt","code":"--@name Class\n--@author Xandaros\n\n--Class library, most recent version can be found here: https://gist.github.com/Xandaros/ea8756e4c4ba00218855\n\nlocal function callConstructor(class, obj, ...)\n    local meta = getmetatable(class)\n    if meta.__super then\n        if class.superArgs then\n            callConstructor(meta.__super, obj, class.superArgs(...))\n        else\n            callConstructor(meta.__super, obj)\n        end\n    end\n    if class.constructor then\n        class.constructor(obj, ...)\n    end\nend\n\nlocal function instantiate(class, ...)\n    local ret = setmetatable({}, {\n        __index = class\n    })\n    callConstructor(class, ret, ...)\n    return ret\nend\n\nfunction Class(name, superclass)\n    local ret = {}\n    setmetatable(ret, {\n        __index = function(self, key)\n            if key ~= \"constructor\" and superclass then\n                return superclass[key]\n            end\n            return nil\n        end,\n        --__index = superclass,\n        __super = superclass,\n        __call = instantiate,\n        __tostring = function() return name or \"unknown\" end\n    })\n    return ret\nend\n\n-- vim: set filetype=lua :\n"},"selectedTab":3}