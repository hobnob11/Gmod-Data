{"1":{"filename":"lib/sekret/octree.txt","code":"--[[\nSpace Combat Octree Builder - Created by Lt.Brandon, based on work by Steeveeo\n\nIf you're not from the diaspora development team and you're viewing this file then please go commit seppuku in the corner :)\n]]--\n\n--Global Tables\nSC.Octree = {}\nSC.Octree.Builder = {}\nSC.Octree.Octant = {}\n\n--Octant Functions\nfunction SC.Octree.Octant:New(Origin, Size, IsRoot, Parent)\n    if not Origin or not Size or ((not IsRoot) and (not Parent)) then\n        print(\"[Space Combat 2 - Octree Builder] Unable to create octant, invalid parameters\\n\")\n        return false\n    end\n\n    local obj = {}\n\tsetmetatable(obj,self)\n    obj.Parent = Parent\n    obj.Size = Size\n    obj.Position = Origin\n    obj.Children = {}\n    obj.IsRoot = IsRoot\n    obj.IsBlocked = false\n\n    if IsRoot then\n        obj.Root = obj\n        obj.OctantCount = 1\n    else\n        obj.Root = Parent.Root\n        obj.Root.OctantCount = obj.Root.OctantCount + 1\n    end\n\n    return obj\nend\n\nfunction SC.Octree.Octant:IsLeaf()\n    return #self.Children == 0\nend\n\nfunction SC.Octree.Octant:IsPointInOctant(Point)\n    local Center = self.Position\n    local Size = self.Size\n    local Min = Center - Vector(Size * 0.5, Size * 0.5, Size * 0.5)\n    local Max = Center + Vector(Size * 0.5, Size * 0.5, Size * 0.5)\n    \n    return Point:WithinAABox(Min, Max)\nend\n\nfunction SC.Octree.Octant:GetPointOctant(Point)\n    if self:IsLeaf() and self:IsPointInOctant(Point) then\n        return self\n    elseif self.Children then\n        local Octants = self.Children\n        for I = 1, 8 do\n            local SubOctant = Octants[I]\n            if SubOctant:IsPointInOctant(Point) then\n                return SubOctant:GetPointOctant(Point)\n            end\n        end\n    else\n        print(\"[Space Combat 2 - Octree Builder] - Unable to find the octant which held the point!\\n\")\n        return false\n    end\nend\n\nfunction SC.Octree.Octant:Check(CheckEntities)\n    local Size = self.Size\n    local Trace = util.TraceHull({\n\t    start = self.Position, \n\t    endpos = self.Position, \n\t    filter = player.GetAll(),\n\t    mins = Vector(self.Size * -0.5, self.Size * -0.5, self.Size * -0.5), \n\t    maxs = Vector(self.Size * 0.5, self.Size * 0.5, self.Size * 0.5),\n        mask = CheckEntities and nil or MASK_NPCWORLDSTATIC\n    })\n\n    if Trace.Hit then\n        return true\n    end\n\n    return false\nend\n\nfunction SC.Octree.Octant:Subdivide()\n    local Origin = self.Position\n    local NewScanVolume = self.Size * 0.5\n    local Dist = NewScanVolume * 0.5\n    \n    local Children = {}\n    Children[1] = SC.Octree.Octant:New(Origin + Vector(Dist, Dist, Dist), NewScanVolume, false, self)\n    Children[2] = SC.Octree.Octant:New(Origin + Vector(Dist, -Dist, Dist), NewScanVolume, false, self)\n    Children[3] = SC.Octree.Octant:New(Origin + Vector(-Dist, Dist, Dist), NewScanVolume, false, self)\n    Children[4] = SC.Octree.Octant:New(Origin + Vector(-Dist, -Dist, Dist), NewScanVolume, false, self)\n    Children[5] = SC.Octree.Octant:New(Origin + Vector(Dist, Dist, -Dist), NewScanVolume, false, self)\n    Children[6] = SC.Octree.Octant:New(Origin + Vector(Dist, -Dist, -Dist), NewScanVolume, false, self)\n    Children[7] = SC.Octree.Octant:New(Origin + Vector(-Dist, Dist, -Dist), NewScanVolume, false, self)\n    Children[8] = SC.Octree.Octant:New(Origin + Vector(-Dist, -Dist, -Dist), NewScanVolume, false, self)\n\n    self.Children = Children\nend\nSC.Octree.Octant.__index = SC.Octree.Octant\n\n--Builder Functions\nfunction SC.Octree.Builder:New(Position, Size, MaxDepth, CheckEntities, MaxQuota, FinishedCallback)\n    local obj = {}\n\tsetmetatable(obj,self)\n    obj.Position = Position\n    obj.Size = Size\n    obj.MaxDepth = MaxDepth\n    obj.CheckEntities = CheckEntities\n    obj.MaxQuota = MaxQuota\n    obj.RootOctant = SC.Octree.Octant:New(Position, Size, true)\n    obj.RootOctant:Subdivide()\n    obj.Finished = false\n    obj.CurDepth = 1\n    obj.CurParent = obj.RootOctant\n    obj.CurOctant = obj.RootOctant.Children[1]\n    obj.OctantIndex = {}\n    obj.OctantIndex[1] = 1\n    obj.FinishedCallback = FinishedCallback\n    obj.StartTime = -1\n    obj.StopTime = -1\n\n    return obj\nend\n\nlocal function quotaCheck ( n ) return ( QuotaUsed() < QuotaMax() * n ) and ( QuotaAverage() < QuotaMax() * n) end\n\nfunction SC.Octree.Builder:Rebuild(running)\n    if not running then self.StartTime = SysTime() end\n    local Finished = self.Finished\n    \n    while quotaCheck(self.MaxQuota) and not Finished do\n        --Check if this octant should be a leaf\n        if not self.CurOctant:Check(self.CheckEntities) then\n            --Iterate back up the Octree\n            while self.OctantIndex[self.CurDepth] >= 8 do\n            \n                self.CurDepth = self.CurDepth - 1\n\n                --Top of tree, break\n                if self.CurDepth < 1 then\n                    Finished = true\n                    break\n                else\n                    self.CurOctant = self.CurParent\n                    self.CurParent = self.CurOctant.Parent\n                end\n            end\n        --We found something, so subdivide\n        else\n            --We are at max depth, pop back up a level\n            if self.CurDepth >= self.MaxDepth then\n                --Mark Invalid\n                self.CurOctant.IsBlocked = true\n                \n                while self.OctantIndex[self.CurDepth] >= 8 do\n                    self.CurDepth = self.CurDepth - 1\n\n                    --Top of tree, break\n                    if self.CurDepth < 1 then\n                        Finished = true\n                        break\n                    else\n                        self.CurOctant = self.CurParent\n                        self.CurParent = self.CurOctant.Parent\n                    end\n                end\n            --Else subdivide and iterate downwards\n            else\n                self.CurOctant:Subdivide()\n                self.CurDepth = self.CurDepth + 1\n                \n                self.OctantIndex[self.CurDepth] = 0\n                self.CurParent = self.CurOctant\n            end\n        end\n                \n        --Next Octant\n        if not Finished then\n            self.OctantIndex[self.CurDepth] = self.OctantIndex[self.CurDepth] + 1\n            self.CurOctant = self.CurParent.Children[self.OctantIndex[self.CurDepth]]\n        end\n    end\n    \n    if not Finished then\n        print(\"[Space Combat 2 - Octree Builder] - Built \"..self.RootOctant.OctantCount..\" Octants\\n\")\n        timer.Simple(0.1, function()\n            if self then\n                self:Rebuild(true)\n            end\n        end)\n    else\n        self.StopTime = SysTime()\n        print(\"[Space Combat 2 - Octree Builder] - Finished Building in \" ..(self.StartTime - self.StopTime)..\".\\n\")\n        self.Finished = true\n\n        if self.FinishedCallback then\n            self:FinishedCallback()\n        end\n    end\nend\nSC.Octree.Builder.__index = SC.Octree.Builder"},"2":{"filename":"octreeeeeeeeeeeeeeeeeeeeees.txt","code":"--@name octreeeeeeeeeeeeeeeeeeeeees\n--@author Hab\n--@include lib/sekret/octree.txt\nif SERVER then \n    require(\"lib/sekret/octree.txt\")\n    \n    --override this so we can hit what we want. \n    function SC.Octree.Octant:Check(CheckEntities)\n        local Size = self.Size\n        local Trace = trace.TraceHull(\n            self.Position, \n    \t    self.Position, \n    \t    Vector(self.Size * -0.5, self.Size * -0.5, self.Size * -0.5), \n    \t    Vector(self.Size * 0.5, self.Size * 0.5, self.Size * 0.5),\n    \t    {},\n            16432\n        )\n        if Trace.Hit then return true else return false end\n    end\n    Memes = false\n    hoboctant = SC.Octree.Builder:New(entities.self():GetPos(), 4096, 5, true, 0.5, function() loop(hoboctant.RootOctant) Memes = true end)\n    hoboctant:Rebuild()\n    local octols = {}\n    function loop(octo)\n        \n        for I = 1 , #octo.Children do\n            local V = octo.Children[I]\n            if #V.Children > 0 then \n                loop(V)\n            end\n            table.insert(octols,V)\n        end\n    end\n    \n    function depthMeter(octo)\n        local Depth = 1\n        local O = octo\n        for I = 1 , hoboctant.MaxDepth do\n            if O.Parent == hoboctant.RootOctant then \n                return Depth\n            else\n                Depth = Depth + 1 \n                O = O.Parent\n            end\n        end\n    end\n    local function quotaCheck ( n )     return ( QuotaUsed() < QuotaMax() * n ) and ( QuotaAverage() < QuotaMax() * n) end\n    local I = 0\n    hook.Add(\"Think\",\"Think\",function()\n        if Memes then \n        while I<#octols and holograms.canSpawn() and quotaCheck(0.8) do\n            if I<#octols and holograms.canSpawn() then\n                I=I+1\n                if depthMeter(octols[I])>=0 then\n                    local E = holograms.create(octols[I].Position,Angle(0,0,0),\"models/sprops/cuboids/height06/size_1/cube_6x6x6.mdl\",Vector(0.16,0.16,0.16)*octols[I].Size)\n                    E:SetMaterial(\"models/wireframe\")\n                    E:SetColor(Color(0,255,0,100))\n                    if octols[I].IsBlocked then \n                        E:SetColor(Color(255,0,0))\n                    end\n                end\n            end\n        end\n    end\n    end)\n\nend"},"3":{"filename":"projects/planet/Hob-LS.txt","code":"--HOB-LS - Dynamic Life Support. \nVERSION = 0.1\n--@name Hob-LS \n\n--many, many libraries\n--@include lib/sekret/octree.txt\n--@include lib/pid.txt\n--@include lib/hob.txt\n--@include lib/HobDebugLib.txt\n\nrequire(\"lib/sekret/octree.txt\")\nrequire(\"lib/pid.txt\")\nrequire(\"lib/hob.txt\")\nrequire(\"lib/HobDebugLib.txt\")\n\n--### CONFIG VARS ### --\n\n--line up models with "},"4":{"filename":"lib/hob.txt","code":"--hob lib, because fuck writing this shit constantly \n--@name YOU PASTED THE FUCKING LIB U FUCK\n\nif SERVER then\n    \n    --Gets closest Planet\n    function FindClosestPlanet(Pos)\n        local Planets = ls.GetPlanets()\n        local Dist = 1e9\n        local Return\n        \n        for K,V in pairs(Planets) do\n            if V:GetPos():Distance(Pos) < Dist then\n                Return = V\n                Dist = V:GetPos():Distance(Pos)\n            end\n        end\n        return Return\n    end\n\nend"},"5":{"filename":"lib/unique.txt","code":"--@name unique\n--@author Hobnob\n--@shared\nif CLIENT then\n    \n    function Unique()\n        if not globaltables.player then\n            globaltables.player = {}\n        end\n        gt = globaltables.player\n        local ret = not gt[1]\n        table.insert(gt,not gt[1])\n        timer.Simple(0.5,function() \n            globaltables.player = {}\n        end)\n        return ret\n    end\n        \nend\n"},"6":{"filename":"lib/HobDebugLib.txt","code":"--@name HobDebugLib\n--@author\n--@shared\n--@include lib/unique.txt\nrequire(\"lib/unique.txt\")\n \nHobDebug = {}\nHobDebug.Level = 0 -- defualt to aww hell naw\nHobDebug.SrcSize = {x=1768,y=992}\nHobDebug.Icons = {\"icon16/bug.png\",\"icon16/bug_error.png\",\"icon16/error.png\",\"icon16/exclamation.png\"}\n-- 0 = debug - prepare for spam\n-- 1 = warn - well that probably shouldent of happened\n-- 2 = error - shits broke yo\n-- 3 = aww hell naw - SHITS BAD YO.\nif SERVER then\n    function HobDebug.PrintError(level, header, message)\n        net.Start(\"HobDebugError\")\n        net.WriteUInt(level,2)\n        net.WriteString(header)\n        net.WriteString(message)\n        net.Send(entities.owner())\n    end\n    function HobDebug.SetDebugLevel(level)\n        level = math.Clamp(level,0,3)\n        net.Start(\"HobDebugSetLevel\")\n        net.WriteUInt(level,2)\n        net.Send(entities.owner())\n        HobDebug.Level = level\n \n    end\n    timer.Simple(2,function()\n        HobDebug.PrintError(3,\"oh noes\",\"you have fucked up now.\")\n    end)\n    timer.Simple(3,function()\n        HobDebug.PrintError(3,\"pls no\",\"you have fucked up now.\")\n    end)\n    timer.Simple(4,function()\n        HobDebug.PrintError(2,\"aie\",\"this is like mostly bad.\")\n    end)\n    timer.Simple(5,function()\n        HobDebug.PrintError(1,\"meh.\",\"no one cares about this.\")\n    end)\n    timer.Simple(6,function()\n        HobDebug.PrintError(0,\"debugh.\",\"spaaaaaaam\")\n    end)\nelseif CLIENT and Unique() then\n    HobDebug.Errors = {}\n    hook.Add(\"net\",\"DebugHook\",function(name,length)\n        if name == \"HobDebugError\" then\n            local level = net.ReadUInt(2)\n            local header= net.ReadString()\n            local message=net.ReadString()\n            table.insert(HobDebug.Errors,{level,header,message})\n            UpdateDebug()\n        elseif name == \"HobDebugSetLevel\" then\n            local level = net.ReadUInt(2)\n            HobDebug.Level = level\n            UpdateDebug()\n        end\n    end)\n    function CreateWindow()\n        HobDebug.DebugConsole = vgui.Create(\"DFrame\")\n        local dc = HobDebug.DebugConsole\n        local ss = HobDebug.SrcSize\n        dc:SetSkin(\"Default\")\n        dc:SetTitle(\"Hob-Co Debug Console\")\n        dc:SetSize(550,300)\n        dc:SetPos(ss.x-550,ss.y-400)\n        dc.List = vgui.Create(\"DListView\",dc)\n        dc.List:SetMultiSelect( false )\n        dc.List:SetSize(530,265)\n        dc.List:SetPos(10,25)\n        dc.List.Level   = dc.List:AddColumn( \"Lvl\" )\n            dc.List.Level:SetMinWidth(18)\n            dc.List.Level:SetMaxWidth(18)\n        dc.List.Title   = dc.List:AddColumn( \"Title\" )\n            dc.List.Title:SetMinWidth(128)\n            dc.List.Title:SetMaxWidth(128)\n        dc.List.Message = dc.List:AddColumn( \"Message\" )\n       \n    end\n    function UpdateDebug()\n        local l = HobDebug.DebugConsole.List\n        l:Clear()\n        for _,e in pairs(HobDebug.Errors) do\n            if e[1] >= HobDebug.Level then\n                local item = l:AddLine(unpack(e))\n                local mat = Material(HobDebug.Icons[e[1]+1])\n                function item:PaintOver(width,height)\n                    surface.SetDrawColor(Color(255,255,255,255))\n                    surface.SetMaterial(mat)\n                    surface.DrawTexturedRect(1,1,height-2,height-2)\n                end\n            end\n        end\nend\n    function HobDebug.SetDebugLevel(level)\n        HobDebug.Level = level\n    end\n    function HobDebug.PrintError(level, header, message)\n        table.insert(HobDebug.Errors,{level,header,message})\n        UpdateDebug()\n    end\n \n    CreateWindow()\n   \n   \n   \n    hook.Add(\"Removed\",\"onLast\",function()\n        HobDebug.DebugConsole:Remove()\n    end)\nend"},"7":{"filename":"Heh.txt","code":"--@name HobScreen\n--@author\n--@shared\n \nif SERVER then\n   \n   \nelse\n    \n    --Players that can see the overview\n    Memers = {\"H08\",\"Kan\",\"Err\"}\n    function IsMemer(Ent) for I =1,#Memers do if Ent == FindPlayerByName(Memers[I]) then return true end end return false end\n        \n    if IsMemer(entities.player()) then\n        Players = find.AllPlayers()\n        LPly = entities.player()\n        TeamColours ={\n            Color(255,255,255), -- 1 ?\n            Color(255,255,255), -- 2 ?\n            Color(255,255,255), -- 3 ?\n            Color(100,255,100), -- 4 Player\n            Color(255,0,0), -- 5 Administrator\n            Color(255,255,0), -- 6 Respected Player\n            Color(255,255,255)} -- clamp\n       \n        surface.CreateFont(\"Memes\",{\n            underline = true})\n       \n        hook.Add(\"HUDPaint\",\"screenhook\",function()\n            --players\n            if(#Players > 0)then\n                for _,P in pairs(Players) do\n                    if(P ~= nil and P:IsValid()) then\n                        if P~=entities.player() then\n                            local toScrn = (P:OBBCenterW()+Vector(0,0,P:OBBSize().z/2 + 10)):ToScreen()\n                            local pos = {x=math.Clamp(toScrn.x,100,surface.ScreenW()-100),y=math.Clamp(toScrn.y,100,surface.ScreenH()-100)}\n                            if(P:Team()) then\n                                surface.SetTextColor(TeamColours[math.Clamp(P:Team(),1,7)])\n                            end\n                            surface.SetFont(\"Default\")\n                            local w,h =surface.GetTextSize(P:GetName())\n                            surface.SetTextPos(pos.x -w/2,pos.y+10)\n                            surface.DrawText(P:GetName())\n                        end\n                    end\n                end\n            end\n        end)\n       \n        timer.Create(\"refresh\",30,0,function()\n            Players = find.AllPlayers()\n        end)\n    end\nend"},"selectedTab":3}